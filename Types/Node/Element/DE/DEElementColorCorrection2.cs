using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Yarhl.IO;

namespace HActLib
{
    [ElementID(Game.LJ, 0x1C9)]
    [ElementID(Game.LAD7Gaiden, 0x1C9)]
    [ElementID(Game.LADIW, 0x1C9)]
    public class DEElementColorCorrection2 : NodeElement
    {
        public uint Size;
        public uint Unk1;
        public float[] Animation = new float[32];

        internal override void ReadElementData(DataReader reader, NodeConvInf inf, GameVersion version)
        {
            long pos = reader.Stream.Position;

            Size = reader.ReadUInt32();
            Unk1 = reader.ReadUInt32();
            Animation = new float[32];

            for (int i = 0; i < Animation.Length; i++)
                Animation[i] = reader.ReadSingle();
        }

        internal override void WriteElementData(DataWriter writer, GameVersion version)
        {
            writer.Write(Size);
            writer.Write(Unk1);
            
            foreach (float f in Animation)
                writer.Write(f);
        }

        public byte[] ToBitmapBytes()
        {
            using (MemoryStream ms = new MemoryStream())
            {
                using (BinaryWriter bw = new BinaryWriter(ms))
                {
                    byte[] bmpHeader2 = null;


                    switch (Size)
                    {
                        default:
                            bmpHeader2 = new byte[] { 0x42, 0x4D, 0x36, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, (byte)Size, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
                            break;
                        case 32:
                            bmpHeader2 = new byte[] { 0x42, 0x4D, 0x36, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, (byte)Size, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
                            break;
                        case 16:
                            bmpHeader2 = new byte[] { 0x42, 0x4D, 0x36, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, (byte)Size, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
                            break;
                    }

                    bw.Write(bmpHeader2);
                    bw.Write(unkBytes);
                }

                return ms.GetBuffer();
            }
        }

        public void ExportToBMP(string path)
        {
            File.WriteAllBytes(path, ToBitmapBytes());
        }
    }
}
